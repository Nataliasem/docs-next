# Слоты

> Подразумевается, что уже изучили и разобрались с разделом [Основы компонентов](component-basics.md). Если нет — прочитайте его сначала.

## Содержимое слота

Vue реализует API распределения контента, вдохновлённое текущим [черновиком спецификации веб-компонентов](https://github.com/w3c/webcomponents/blob/gh-pages/proposals/Slots-Proposal.md), используя элемент `<slot>` в качестве точек распространения контента.

Что позволяет создавать например такие компоненты:

```html
<todo-button>
  Добавить todo
</todo-button>
```

Шаблон `<todo-button>` может выглядеть примерно так:

```html
<!-- шаблон компонента todo-button -->
<button class="btn-primary">
  <slot></slot>
</button>
```

При отрисовке компонента `<slot></slot>` будет заменён на «Добавить todo».

```html
<!-- отрисованный HTML -->
<button class="btn-primary">
  Добавить todo
</button>
```

И строки — это только начало! Слоты могут содержать код любого шаблона, даже HTML:

```html
<todo-button>
  <!-- Добавляем иконку Font Awesome -->
  <i class="fas fa-plus"></i>
  Добавить todo
</todo-button>
```

Или даже другие компоненты:

```html
<todo-button>
  <!-- Используем компонент для добавления иконки -->
  <font-awesome-icon name="plus"></font-awesome-icon>
  Добавить todo
</todo-button>
```

Если шаблон `<todo-button>` **не будет содержать** элемента `<slot>`, то любой переданный контент просто игнорируется.

```html
<!-- В шаблоне компонента todo-button НЕТ <slot> -->
<button class="btn-primary">
  Создать новый элемент
</button>
```

```html
<todo-button>
  <!-- Этот текст НЕ БУДЕТ ОТРИСОВАН -->
  Добавить todo
</todo-button>
```

## Область видимости при отрисовке

Если потребуется использовать данные внутри слота, например:

```html
<todo-button>
  Удалить {{ item.name }}
</todo-button>
```

То в таком слоте будет доступ к тем же свойствам экземпляра (т.е. к той же «области видимости»), как и в остальной части шаблона.

<img src="/images/slot.png" width="447" height="auto" style="display: block; margin: 0 auto; max-width: 100%" loading="lazy" alt="Пояснительная диаграмма для слота">

У слота **нет доступа** к области видимости `<todo-button>`. Поэтому попытка обратиться к входному параметру `action` не сработает:

```html
<todo-button action="delete">
  Клик вызовет действие {{ action }} для элемента
  <!--
  Значение `action` будет undefined, потому что это содержимое передаётся
  ВНУТРЬ <todo-button>, а не определяется СНАРУЖИ компонента <todo-button>.
  -->
</todo-button>
```

Обычно достаточно запомнить что:

> Всё в родительском шаблоне компилируется в области видимости родительского компонента; всё в шаблоне дочернего компилируется в области видимости дочернего компонента.

## Содержимое слота по умолчанию

Часто полезно указать содержимое слота по умолчанию, которое будет использоваться только когда ничего не передаётся в слот. Например, для компонента `<submit-button>`:

```html
<button type="submit">
  <slot></slot>
</button>
```

Удобнее указать текст по умолчанию «Отправить», который будет отображаться большую часть времени. Для этого нужно сделать «Отправить» содержимым по умолчанию, поместив его между тегами `<slot>`:

```html
<button type="submit">
  <slot>Отправить</slot>
</button>
```

Теперь, используя `<submit-button>` в родительском компоненте и не указывая содержимое для слота:

```html
<submit-button></submit-button>
```

будет отображаться содержимое по умолчанию — «Отправить»:

```html
<button type="submit">
  Отправить
</button>
```

Но стоит определить его:

```html
<submit-button>
  Сохранить
</submit-button>
```

и оно будет использовано для отображения:

```html
<button type="submit">
  Сохранить
</button>
```

## Именованные слоты

Зачастую удобно иметь несколько слотов. К примеру, для компонента `<base-layout>` со следующим шаблоном:

```html
<div class="container">
  <header>
    <!-- Здесь должен быть заголовок -->
  </header>
  <main>
    <!-- Здесь основной контент -->
  </main>
  <footer>
    <!-- Здесь контент подвала -->
  </footer>
</div>
```

В таких случаях элементу `<slot>` можно указать специальный атрибут `name`, который будет использован для присвоения уникального ID различным слотам, чтобы определить где какое содержимое необходимо отобразить:

```html
<div class="container">
  <header>
    <slot name="header"></slot>
  </header>
  <main>
    <slot></slot>
  </main>
  <footer>
    <slot name="footer"></slot>
  </footer>
</div>
```

Элемент `<slot>` без `name` неявно получает имя «default».

Для объявления содержимого для именованного слота, необходимо воспользоваться директивой `v-slot` на элементе `<template>`, передав имя слота аргументом `v-slot`:

```html
<base-layout>
  <template v-slot:header>
    <h1>Здесь мог быть заголовок страницы</h1>
  </template>

  <template v-slot:default>
    <p>Параграф для основного контента.</p>
    <p>И ещё один.</p>
  </template>

  <template v-slot:footer>
    <p>Некая контактная информация</p>
  </template>
</base-layout>
```

Теперь содержимое элементов `<template>` будет передаваться в соответствующие слоты.

Отрисованный HTML получится таким:

```html
<div class="container">
  <header>
    <h1>Здесь мог быть заголовок страницы</h1>
  </header>
  <main>
    <p>Параграф для основного контента.</p>
    <p>И ещё один.</p>
  </main>
  <footer>
    <p>Некая контактная информация</p>
  </footer>
</div>
```

Запомните, **`v-slot` можно добавлять только на теги `<template>`** (с [одним исключением](#сокращенныи-синтаксис-для-единственного-слота-по-умолчанию)).

## Слоты с ограниченной областью видимости

Иногда в содержимом слота может потребоваться доступ к данным, доступным только в дочернем компоненте. Частый случай подобного — когда в компоненте отображается массив элементов, и нужна возможность управлять отрисовкой каждого элемента.

Например, есть компонент со списком дел:

```js
app.component('todo-list', {
  data() {
    return {
      items: ['Покормить кота', 'Купить молока']
    }
  },
  template: `
    <ul>
      <li v-for="(item, index) in items">
        {{ item }}
      </li>
    </ul>
  `
})
```

Заменим <span v-pre>`{{ item }}`</span> на `<slot>` для управления отрисовкой в родительском компоненте:

```html
<todo-list>
  <i class="fas fa-check"></i>
  <span class="green">{{ item }}</span>
</todo-list>
```

К сожалению так это не сработает, потому что только у компонента `<todo-list>` есть доступ к `item`, а в этом примере содержимое слота указывается в родительском.

Чтобы в родительском компоненте предоставить доступ к `item` для содержимого слота, необходимо добавить элемент `<slot>` и привязать требуемые данные атрибутом:

```html
<ul>
  <li v-for="(item, index) in items">
    <slot :item="item"></slot>
  </li>
</ul>
```

Можно привязывать к `slot` любое количество атрибутов:

```html
<ul>
  <li v-for="(item, index) in items">
    <slot
      :item="item"
      :index="index"
      :another-attribute="anotherAttribute"
    ></slot>
  </li>
</ul>
```

Атрибуты, привязанные к элементу `<slot>`, называются **входными параметрами слота**. Теперь, в родительской области видимости, можно использовать `v-slot` со значением, чтобы определить имя переменной с входными параметрами, привязанными к слоту:

```html
<todo-list>
  <template v-slot:default="slotProps">
    <i class="fas fa-check"></i>
    <span class="green">{{ slotProps.item }}</span>
  </template>
</todo-list>
```

<img src="/images/scoped-slot.png" width="611" height="auto" style="display: block; margin: 0 auto; max-width: 100%;" loading="lazy" alt="Диаграмма слотов с ограниченной областью видимости">

В этом примере объект со всеми входными параметрами слота будет с именем `slotProps`, но можно использовать и любое другое, которое нравится.

### Сокращённый синтаксис для единственного слота по умолчанию

Если указывается содержимое _только для слота по умолчанию_, то можно использовать тег компонента в качестве шаблона слота и можно указывать `v-slot` сразу на компоненте:

```html
<todo-list v-slot:default="slotProps">
  <i class="fas fa-check"></i>
  <span class="green">{{ slotProps.item }}</span>
</todo-list>
```

Такую запись можно сократить ещё больше. Предполагается, что содержимое относится к слоту по умолчанию, если иного не указано явно, поэтому `v-slot` без аргумента означает слот по умолчанию:

```html
<todo-list v-slot="slotProps">
  <i class="fas fa-check"></i>
  <span class="green">{{ slotProps.item }}</span>
</todo-list>
```

Обратите внимание, что подобный сокращённый синтаксис для слота по умолчанию **нельзя смешивать** с именованными слотами, потому что это приводит к неоднозначности области видимости:

```html
<!-- НЕПРАВИЛЬНО, будет выбрасываться предупреждение -->
<todo-list v-slot="slotProps">
  <i class="fas fa-check"></i>
  <span class="green">{{ slotProps.item }}</span>

  <template v-slot:other="otherSlotProps">
    slotProps здесь НЕДОСТУПНЫ
  </template>
</todo-list>
```

При наличии нескольких слотов всегда используйте полный синтаксис с объявлением элементов `<template>` для _всех_ слотов:

```html
<todo-list>
  <template v-slot:default="slotProps">
    <i class="fas fa-check"></i>
    <span class="green">{{ slotProps.item }}</span>
  </template>

  <template v-slot:other="otherSlotProps">
    ...
  </template>
</todo-list>
```

### Деструктуризация входных параметров слота

Под капотом, слоты с ограниченной областью видимости оборачивают своё содержимое слота в функцию, которая аргументом принимает входные параметры:

```js
function(slotProps) {
  // ... содержимое слота ...
}
```

Поэтому значение `v-slot` может быть любым допустимым выражением JavaScript, которое допустимо использовать на позиции аргумента определения функции. Например можно применять [деструктурирование ES2015](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#%D0%A0%D0%B0%D0%B7%D0%B1%D0%BE%D1%80_%D0%BE%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%BE%D0%B2), чтобы получать определённые входные параметры слота:

```html
<todo-list v-slot="{ item }">
  <i class="fas fa-check"></i>
  <span class="green">{{ item }}</span>
</todo-list>
```

Такой подход делает шаблон намного чище, особенно если у слота множество входных параметров. Это открывает и другие возможности, например, переименование свойства `item` в `todo` используемого входного параметра:

```html
<todo-list v-slot="{ item: todo }">
  <i class="fas fa-check"></i>
  <span class="green">{{ todo }}</span>
</todo-list>
```

Кроме того, можно определить значение по умолчанию, которое будет использоваться если входной параметр для слота не был определён:

```html
<todo-list v-slot="{ item = 'Нет информации' }">
  <i class="fas fa-check"></i>
  <span class="green">{{ item }}</span>
</todo-list>
```

## Динамическое имя слота

[Динамические аргументы директивы](template-syntax.md#динамические-аргументы) работают и с `v-slot`, что позволяет установить динамическое имя слота:

```html
<base-layout>
  <template v-slot:[dynamicSlotName]>
    ...
  </template>
</base-layout>
```

## Сокращённая запись именованных слотов

Кроме `v-on` и `v-bind`, есть сокращённая запись и у `v-slot`, которая заменяет всё перед аргументом (`v-slot:`) на символ `#`, а `v-slot:header` можно сократить до `#header`:

```html
<base-layout>
  <template #header>
    <h1>Здесь мог быть заголовок страницы</h1>
  </template>

  <template #default>
    <p>Параграф для основного контента.</p>
    <p>И ещё один.</p>
  </template>

  <template #footer>
    <p>Некая контактная информация</p>
  </template>
</base-layout>
```

Однако, как и с другими директивами, сокращение можно использовать только при наличии аргумента и следующий синтаксис будет неправильным:

```html
<!-- НЕ ЗАРАБОТАЕТ и выкинет предупреждение -->
<todo-list #="{ item }">
  <i class="fas fa-check"></i>
  <span class="green">{{ item }}</span>
</todo-list>
```

Необходимо всегда указывать имя слота, чтобы использовать сокращённую запись:

```html
<todo-list #default="{ item }">
  <i class="fas fa-check"></i>
  <span class="green">{{ item }}</span>
</todo-list>
```
