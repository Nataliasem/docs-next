# Управление состоянием приложения

## Официальная Flux-подобная библиотека

Большие приложения часто могут усложняться из-за множества фрагментов состояния, разбросанных по многим компонентам, и взаимодействий между ними. Для решения этой проблемы Vue предлагает [Vuex](https://next.vuex.vuejs.org/) — собственную библиотеку для управления состоянием, вдохновлённую языком Elm. Она интегрируется с [vue-devtools](https://github.com/vuejs/vue-devtools) и позволяет заниматься [отладкой с функцией «машиной времени»](https://raw.githubusercontent.com/vuejs/vue-devtools/master/media/demo.gif).

### Информация для React-разработчиков

При переходе на Vue с React, может быть интересно как Vuex сравнивается с [Redux](https://github.com/reactjs/redux), самой популярной реализацией Flux в этой экосистеме. Redux не зависит от слоя представления, поэтому его можно легко использовать и с Vue с помощью [простых привязок](https://classic.yarnpkg.com/en/packages?q=redux%20vue&p=1). Vuex отличается тем, что он _знает_, что находится в приложении Vue. Это позволяет ему лучше интегрироваться и предлагать более интуитивно понятный API, улучшая процесс разработки.

## Создание простого контейнера состояния с нуля

Часто упускается из виду, что «источником истины» в приложениях Vue будет реактивный объект `data` — экземпляр компонента лишь проксируют доступ к нему. Поэтому, если есть часть состояния, которая должна быть общей для нескольких экземпляров, то можно воспользоваться методом [reactive](reactivity-fundamentals.md#объявление-реактивного-состояния), чтобы сделать объект реактивным:

```js
const { createApp, reactive } = Vue

const sourceOfTruth = reactive({
  message: 'Привет'
})

const appA = createApp({
  data() {
    return sourceOfTruth
  }
}).mount('#app-a')

const appB = createApp({
  data() {
    return sourceOfTruth
  }
}).mount('#app-b')
```

```html
<div id="app-a">Приложение A: {{ message }}</div>

<div id="app-b">Приложение B: {{ message }}</div>
```

Сейчас при изменении `sourceOfTruth` оба приложения `appA` и `appВ` будут автоматически обновлять свои представления. Теперь есть единый источник истины, но отладка станет кошмаром. Любая часть данных может быть изменена в любой части приложения в любое время, не оставляя никаких следов.

```js
const appB = createApp({
  data() {
    return sourceOfTruth
  },
  mounted() {
    sourceOfTruth.message = 'Пока' // оба приложения теперь показывают 'Пока'
  }
}).mount('#app-b')
```

Для решения этой проблемы можно адаптировать **шаблон проектирования «состояние»**:

```js
const store = {
  debug: true,

  state: reactive({
    message: 'Привет!'
  }),

  setMessageAction(newValue) {
    if (this.debug) {
      console.log('setMessageAction вызван с', newValue)
    }

    this.state.message = newValue
  },

  clearMessageAction() {
    if (this.debug) {
      console.log('clearMessageAction вызван')
    }

    this.state.message = ''
  }
}
```

Обратите внимание, что все действия, которые изменяют состояние хранилища, помещены в него. Такой подход к централизованному управлению состоянием позволяет легче понять, какие типы мутаций могут произойти и как они вызываются. Теперь, когда что-то пойдёт не так — у нас будет журнал событий с последовательностью действий, приведших к ошибке.

При этом в каждом экземпляре/компоненте может быть и своё собственное состояние, которым он управляет:

```html
<div id="app-a">{{ sharedState.message }}</div>

<div id="app-b">{{ sharedState.message }}</div>
```

```js
const appA = createApp({
  data() {
    return {
      privateState: {},
      sharedState: store.state
    }
  },
  mounted() {
    store.setMessageAction('Пока!')
  }
}).mount('#app-a')

const appB = createApp({
  data() {
    return {
      privateState: {},
      sharedState: store.state
    }
  }
}).mount('#app-b')
```

![Управление состоянием](/images/state.png)

:::tip Совет
**Не стоит заменять исходный объект состояния** в своих действиях — компоненты и хранилище должны ссылаться на один и тот же объект для отслеживания мутаций.
:::

Если продолжить развивать концепцию, в которой компонентам не разрешается напрямую изменять состояние хранилища, а вместо этого они должны отправлять события, которые уведомляют хранилище о необходимости выполнения каких-то действий, то в конечном итоге приходим к архитектуре [Flux](https://facebook.github.io/flux/). Преимущество этой архитектуры заключается в том, что можно записывать все мутации состояния, происходящие с хранилищем, и создавать продвинутые средства для отладки, такие как журналы мутаций, моментальные снимки и путешествие по истории изменений / «машину времени».

Это вновь возвращает к [Vuex](https://vuex.vuejs.org/ru/), поэтому если дочитали до этого момента — пожалуй, пришло время попробовать!
