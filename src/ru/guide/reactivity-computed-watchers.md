# Вычисляемые свойства и методы-наблюдатели

> Этот раздел использует синтаксис [однофайловых компонентов](single-file-component.md) в примерах кода

## Вычисляемые свойства

Иногда требуется состояние, зависящее от другого состояния — во Vue это реализуется с помощью [вычисляемых свойств](computed.md#вычисляемые-своиства) компонента. Но можно создавать вычисляемые свойства и напрямую, с помощью метода `computed`. Он принимает функцию геттера и возвращает реактивный иммутабельный [ref](reactivity-fundamentals.md#создание-автономных-ссылок-на-реактивные-значения) объект для значения, возвращаемого из геттера.

```js{2}
const count = ref(1)
const plusOne = computed(() => count.value + 1)

console.log(plusOne.value) // 2

plusOne.value++ // ошибка
```

Для создания изменяемого ref-объекта можно передать объект с функциями `get` и `set`.

```js{2-7}
const count = ref(1)
const plusOne = computed({
  get: () => count.value + 1,
  set: val => {
    count.value = val - 1
  }
})

plusOne.value = 1
console.log(count.value) // 0
```

## `watchEffect`

Чтобы применить и _автоматически применить повторно_ побочный эффект, который основан на реактивном состоянии, можно использовать метод `watchEffect`. Он запускает функцию немедленно при отслеживании своих зависимостей и будет повторно запускать её при изменении одной из зависимостей.

```js
const count = ref(0)

watchEffect(() => console.log(count.value))
// -> выведет в консоль 0

setTimeout(() => {
  count.value++
  // -> выведет в консоль 1
}, 100)
```

### Остановка отслеживания

Если `watchEffect` вызывается во время работы функции компонента [setup()](composition-api-setup.md) или во время [хуков жизненного цикла](composition-api-lifecycle-hooks.md), то он привязывается к жизненному циклу компонента и будет автоматически останавливаться при размонтировании компонента.

Для явной остановки отслеживания можно вызвать метод, который он возвращает:

```js
const stop = watchEffect(() => {
  /* ... */
})

// позднее
stop()
```

### Аннулирование побочных эффектов

Иногда в функции наблюдателя могут быть асинхронные побочные эффекты, которые требуют дополнительных действий при их аннулировании (т.е. в случаях, когда состояние изменилось до того как эффекты завершились). Для таких случаев функция эффекта принимает функцию `onInvalidate`, которая будет использоваться для аннулирования выполненного и вызываться:

- когда эффект будет вскоре запущен повторно
- когда наблюдатель остановлен (т.е. когда компонент размонтирован, если `watchEffect` используется внутри `setup()` или хука жизненного цикла)

```js
watchEffect(onInvalidate => {
  const token = performAsyncOperation(id.value)
  
  onInvalidate(() => {
    // id был изменён или наблюдатель остановлен.
    // аннулирование выполняемой асинхронной операции
    token.cancel()
  })
})
```

Коллбэк для аннулирования регистрируется передачей функции внутрь, а не возвращением её из коллбэка, потому что для обработки асинхронных ошибок важно возвращаемое значение. Очень часто функция эффекта будет асинхронной при операциях загрузки данных:

```js
const data = ref(null)

watchEffect(async (onInvalidate) => {
  onInvalidate(() => { /* ... */ }) // регистрируем функцию перед разрешением Promise
  data.value = await fetchData(props.id)
})
```

Асинхронная функция неявно возвращает Promise, но зарегистрировать функцию для очистки нужно перед разрешением Promise. Кроме того, Vue полагается на возвращаемый Promise для автоматической обработки потенциальных ошибок в цепочке Promise.

### Синхронизация времени очистки эффектов

Система реактивности Vue буферизирует аннулированные эффекты и выполняет их очистку асинхронно. Это сделано для избежания повторяющихся вызовов, когда в одном «тике» происходит много изменений состояния. Внутренняя функция компонента `update` также является эффектом. При добавлении пользовательского эффекта в очередь, по умолчанию он будет вызываться **перед** всеми эффектами `update` компонента:

```html
<template>
  <div>{{ count }}</div>
</template>

<script>
  export default {
    setup() {
      const count = ref(0)

      watchEffect(() => {
        console.log(count.value)
      })

      return {
        count
      }
    }
  }
</script>
```

В этом примере:

- Значение счётчика будет выведено в консоль синхронно при первом запуске.
- При изменениях `count`, коллбэк будет вызываться **перед** обновлением компонента.

В случаях, когда эффект наблюдателя требуется повторно запускать **после** обновления компонента (например, при работе [со ссылками на элемента шаблона](composition-api-template-refs.md#отслеживание-ссылок-на-элементы-шаблона)), можно передать дополнительный объект настроек с опцией `flush` (значение по умолчанию — `'pre'`):

```js
// Будет вызываться после обновления компонента,
// поэтому можно получить доступ к обновлённому DOM
// Примечание: это также отложит первоначальный запуск эффекта
// до тех пор, пока первая отрисовка компонента не будет завершена.
watchEffect(
  () => {
    /* ... */
  },
  {
    flush: 'post'
  }
)
```

Опция `flush` также может принимать значение `'sync'`, которое принудительно заставит эффект всегда срабатывать синхронно. Однако такое поведение неэффективно и должно использоваться в крайних случаях.

### Отладка наблюдателей

Можно использовать опции `onTrack` и `onTrigger` для отладки поведения наблюдателя.

- `onTrack` вызывается, когда реактивное свойство или ссылка начинает отслеживаться как зависимость.
- `onTrigger` вызывается, когда коллбэк наблюдателя вызван изменением зависимости.

Оба коллбэка получают событие отладчика с информацией о зависимости, о которой идёт речь. Рекомендуем указывать `debugger` в них для удобного инспектирования зависимости:

```js
watchEffect(
  () => {
    /* побочный эффект */
  },
  {
    onTrigger(e) {
      debugger
    }
  }
)
```

Обратите внимание, опции `onTrack` и `onTrigger` работают только в режиме разработки.

## `watch`

API `watch` является полным эквивалентом свойства [watch](computed.md#методы-наблюдатели) компонента. `watch` требуется конкретный источник данных для наблюдения и выполняет побочные эффекты в отдельной функции коллбэка. Он также ленив по умолчанию — т.е. коллбэк вызывается только тогда, когда наблюдаемый источник изменился.

- По сравнению с [watchEffect](#watcheffect), `watch` позволяет:

  - Лениво выполнять побочные эффекты;
  - Точнее определять какое состояние должно вызвать перезапуск;
  - Получать доступ к предыдущему и текущему значению наблюдаемого состояния.

### Отслеживание одного источника данных

В качестве источника данных для наблюдателя можно указать функцию-геттер, которая вернёт значение, или непосредственно реактивную ссылку `ref`:

```js
// наблюдение за геттер-функцией
const state = reactive({ count: 0 })
watch(
  () => state.count,
  (count, prevCount) => {
    /* ... */
  }
)

// наблюдение за ref-ссылкой
const count = ref(0)
watch(count, (count, prevCount) => {
  /* ... */
})
```

### Отслеживание нескольких источников данных

Можно отслеживать также и несколько источников одновременно, используя синтаксис наблюдателя с массивом:

```js
const firstName = ref('');
const lastName = ref('');

watch([firstName, lastName], (newValues, prevValues) => {
  console.log(newValues, prevValues);
})

firstName.value = "John"; // выведет в консоль: ["John",""] ["", ""]
lastName.value = "Smith"; // выведет в консоль: ["John", "Smith"] ["John", ""]
```

### Отслеживание реактивных объектов

Для сравнения значений массива или объекта, которые являются реактивными, наблюдателю потребуются, чтобы у него была копия, состоящая только из значений.

```js
const numbers = reactive([1, 2, 3, 4])

watch(
  () => [...numbers],
  (numbers, prevNumbers) => {
    console.log(numbers, prevNumbers);
  })

numbers.push(5) // Выведет в консоль: [1,2,3,4,5] [1,2,3,4]
```

При необходимости отслеживать изменения свойств в глубоко вложенном объекте или массиве нужно установить опцию `deep` в значение `true`:

```js
const state = reactive({ 
  id: 1, 
  attributes: { 
    name: "",
  },
});

watch(
  () => state,
  (state, prevState) => {
    console.log(
      "без опции deep ",
      state.attributes.name,
      prevState.attributes.name
    );
  }
);

watch(
  () => state,
  (state, prevState) => {
    console.log(
      "с опцией deep ",
      state.attributes.name,
      prevState.attributes.name
    );
  },
  { deep: true }
);

state.attributes.name = "Alex"; // выведет в консоль: "с опцией deep " "Alex" "Alex"
```

Однако, при отслеживании реактивного объекта или массива будет всегда возвращаться одна ссылка на текущее значение этого объекта как для текущего, так и для предыдущего состояния. Для полноценного отслеживания глубоко вложенных объектов или массивов, может потребоваться создавать глубокую копию значений. Это можно сделать например с помощью утилиты [lodash.cloneDeep](https://lodash.com/docs/4.17.15#cloneDeep)

```js
import _ from 'lodash';

const state = reactive({
  id: 1,
  attributes: {
    name: "",
  },
});

watch(
  () => _.cloneDeep(state),
  (state, prevState) => {
    console.log(
      state.attributes.name, 
      prevState.attributes.name
    );
  }
);

state.attributes.name = "Alex"; // Выведет в консоль: "Alex" ""
```

### Общее поведение с `watchEffect`

Общее поведение `watch` и [`watchEffect`](#watcheffect) — в возможностях [остановки отслеживания](#остановка-отслеживания), [аннулировании побочных эффектов](#аннулирование-побочных-эффектов) (с передачей коллбэка `onInvalidate` третьим аргументом), [синхронизации времени очистки эффектов](#синхронизация-времени-очистки-эффектов) и инструментов [отладки](#отладка-наблюдателеи).
