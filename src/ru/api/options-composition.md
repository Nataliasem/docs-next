# Композиция

## mixins

- **Тип:** `Array<Object>`

- **Подробности:**

  Опция `mixins` принимает массив объектов примесей. Эти объекты могут содержать опции экземпляра, как и обычные объекты экземпляра, и они будут объединены в окончательный набор опций с использованием специальной логики объединения. Например, если хук `created` указан в примеси и есть в компоненте, то будут вызваны обе функции.

  Хуки в примесях вызываются в порядке их определения до вызова собственных хуков компонента.

:::info Информация
Во Vue 2, примеси были основным механизмом для создания многократно используемых фрагментов логики компонентов. Хотя примеси продолжают поддерживаться во Vue 3, теперь [Composition API](../guide/composition-api-introduction.md) является предпочтительным подходом для повторного использования кода между компонентами.
:::

- **Пример:**

  ```js
  const mixin = {
    created() {
      console.log(1)
    }
  }

  createApp({
    created() {
      console.log(2)
    },
    mixins: [mixin]
  })

  // => 1
  // => 2
  ```

- **См. также:** [Примеси](../guide/mixins.md)

## extends

- **Тип:** `Object`

- **Подробности:**

  Позволяет одному компоненту расширять другой, наследуя его опции.

  С точки зрения реализации, `extends` очень похож на `mixins`. Компонент, указанный с помощью `extends`, будет рассматриваться так же, как если бы он был первой примесью.

  Однако `extends` и `mixins` преследуют разные цели. Опция `mixins` в основном используется для компоновки функциональных блоков, в то время как `extends` в основном связана с наследованием.

  Как и в случае с `mixins`, любые опции будут объединены с использованием соответствующей стратегии объединения.

- **Пример:**

  ```js
  const CompA = { ... }

  const CompB = {
    extends: CompA,
    ...
  }
  ```

## provide / inject

- **Тип:**

  - **provide:** `Object | () => Object`
  - **inject:** `Array<string> | { [key: string]: string | Symbol | Object }`

- **Подробности:**

  Эта пара опций используется вместе, чтобы позволить компоненту-родителю внедрять зависимости во все компоненты-потомки. Не имеет значения, насколько глубоко в иерархии они находятся, пока располагаются в той же самой родительской цепочке. Если знакомы с React, то это очень похоже на функцию `context`.

  Опция `provide` должна быть объектом или функцией, возвращающей объект. Этот объект содержит свойства, которые после внедрения будут доступны в потомках. Можно использовать ES2015 Symbols в качестве ключей объекта, но только в окружениях, которые нативно поддерживают `Symbol` и `Reflect.ownKeys`.

  Опция `inject` должна быть:

  - массивом строк;
  - или объектом, где ключами являются локальные имена привязки, а значением может быть:
    - ключ (строка или Symbol) для поиска в доступных внедрениях;
    - объект, в котором
      - свойство `from` является ключом (строка или Symbol) для поиска в доступных внедрениях,
      - свойство `default` используется в качестве запасного значения.

  > Примечание: привязки `provide` и `inject` НЕ РЕАКТИВНЫ. Так сделано специально. Однако, если передать реактивный объект, то его свойства останутся реактивными.

- **Пример:**

  ```js
  // родительский компонент предоставляет доступ к 'foo'
  const Provider = {
    provide: {
      foo: 'bar'
    }
    // ...
  }

  // дочерний компонент внедряет 'foo' для использования
  const Child = {
    inject: ['foo'],
    created() {
      console.log(this.foo) // => "bar"
    }
    // ...
  }
  ```

  Работа с функциями `provide` и объектом `inject` с использованием ES2015 Symbols:

  ```js
  const s = Symbol()

  const Provider = {
    provide() {
      return {
        [s]: 'foo'
      }
    }
  }

  const Child = {
    inject: { s }
    // ...
  }
  ```

  Использование внедряемого значения для входного параметра в качестве значения по умолчанию:

  ```js
  const Child = {
    inject: ['foo'],
    props: {
      bar: {
        default() {
          return this.foo
        }
      }
    }
  }
  ```

  Использование внедряемого значения в качестве данных:

  ```js
  const Child = {
    inject: ['foo'],
    data() {
      return {
        bar: this.foo
      }
    }
  }
  ```

  Инъекции можно указывать с собственным значением по умолчанию:

  ```js
  const Child = {
    inject: {
      foo: { default: 'foo' }
    }
  }
  ```

  Для внедрения значение из свойства под другим именем можно использовать опцию `from` для определения свойства-источника:

  ```js
  const Child = {
    inject: {
      foo: {
        from: 'bar',
        default: 'foo'
      }
    }
  }
  ```

  Как и для значений по умолчанию входных параметров, для не-примитивных значений необходимо использовать фабричную функцию:

  ```js
  const Child = {
    inject: {
      foo: {
        from: 'bar',
        default: () => [1, 2, 3]
      }
    }
  }
  ```

- **См. также:** [Provide / Inject](../guide/component-provide-inject.md)

## setup

- **Тип:** `Function`

Функция `setup` — новая опция компонента. Она будет стартовой точкой для использования Composition API внутри компонентов.

- **Время вызова**

  Функция `setup` вызывается сразу после первичного разрешения входных параметров, когда создаётся экземпляр компонента. В жизненном цикле вызов будет перед хуком [beforeCreate](options-lifecycle-hooks.md#beforecreate).

- **Использование с шаблонами**

  Если `setup` возвращает объект, его свойства будут объединены в контексте отрисовки для шаблона компонента:

  ```html
  <template>
    <div>{{ count }} {{ object.foo }}</div>
  </template>

  <script>
    import { ref, reactive } from 'vue'

    export default {
      setup() {
        const count = ref(0)
        const object = reactive({ foo: 'bar' })

        // предоставляем доступ в шаблоне
        return {
          count,
          object
        }
      }
    }
  </script>
  ```

  Обратите внимание, что [refs](refs-api.md#ref), возвращаемые из `setup`, автоматически разворачиваются при обращениях в шаблоне. Поэтому нет необходимости указывать `.value` в шаблонах.

- **Использование с render-функциями / JSX**

  Функция `setup` также может возвращать render-функцию, которая может напрямую использовать реактивное состояние, объявленное в той же области видимости:

  ```js
  import { h, ref, reactive } from 'vue'

  export default {
    setup() {
      const count = ref(0)
      const object = reactive({ foo: 'bar' })

      return () => h('div', [count.value, object.foo])
    }
  }
  ```

- **Аргументы**

  Первым аргументом функция принимает разрешённые входные параметры:

  ```js
  export default {
    props: {
      name: String
    },
    setup(props) {
      console.log(props.name)
    }
  }
  ```

  Обратите внимание, что объект `props` является реактивным — т.е. он обновляется при передаче новых значений входных параметров. Это позволяет его отслеживать и реагировать на изменения с помощью `watchEffect` или `watch`:

  ```js
  export default {
    props: {
      name: String
    },
    setup(props) {
      watchEffect(() => {
        console.log(`Имя: ` + props.name)
      })
    }
  }
  ```

  **НЕ ИСПОЛЬЗУЙТЕ** деструктуризацию для объекта `props`, потому что это приведёт к потере его реактивности:

  ```js
  export default {
    props: {
      name: String
    },
    setup({ name }) {
      watchEffect(() => {
        console.log(`Имя: ` + name) // Реактивности уже не будет!
      })
    }
  }
  ```

  Объект `props` иммутабелен для пользовательского кода в процессе разработки (будет выводиться предупреждение при попытке его изменять).

  Второй аргумент предоставляет объект с контекстом, который позволяет получить доступ к различным объектам и функциям, полезным внутри `setup`:

  ```js
  const MyComponent = {
    setup(props, context) {
      context.attrs
      context.slots
      context.emit
      context.expose
    }
  }
  ```

  `attrs`, `slots` и `emit` являются эквивалентами свойств экземпляра [`$attrs`](instance-properties.md#attrs), [`$slots`](instance-properties.md#slots) и [`$emit`](instance-methods.md#emit) соответственно.

  Свойства `attrs` и `slots` являются прокси для соответствующих значений экземпляра внутреннего компонента. Это гарантирует, что они всегда содержат актуальные значения даже после обновления, чтобы была возможность уничтожать их, не беспокоясь о доступе по устаревшей ссылке:

  ```js
  const MyComponent = {
    setup(props, { attrs }) {
      // функция, которая может вызываться где-то позднее
      function onClick() {
        console.log(attrs.foo) // гарантированно будет актуальной ссылкой
      }
    }
  }
  ```

  В версии Vue 3.2 добавлена `expose` —  функция, позволяющая объявить определённые свойства через публичный экземпляр компонента. По умолчанию, публичный экземпляр, полученный с помощью `$refs`, `$parent` или `$root` эквивалентен внутреннему экземпляру, используемому шаблоном. При вызове `expose` будет создан отдельный публичный экземпляр с объявленными свойствами:

  ```js
  const MyComponent = {
    setup(props, { expose }) {
      const count = ref(0)
      const reset = () => count.value = 0
      const increment = () => count.value++

      // Только метод reset будет доступен извне, например через $refs
      expose({
        reset
      })

      // Внутри у шаблона будет доступ к count и increment
      return { count, increment }
    }
  }
  ```

  Есть ряд причин, почему `props` указываются в качестве отдельного первого аргумента, а не включаются в контекст:

  - Гораздо чаще компонент использует `props`, чем какие-либо другие свойства. Очень часто компонент использует только `props`.

  - Наличие `props` в качестве отдельного аргумента облегчает вывод их типов, без путаницы с типами других свойств в контексте. Это также позволяет сохранить консистентную сигнатуру между `setup`, `render` и простыми функциональными компонентами с поддержкой TSX.

- **См. также:** [Composition API](composition-api.md)
